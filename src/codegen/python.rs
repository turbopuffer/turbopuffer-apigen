use std::collections::{BTreeMap, HashSet};
use std::error::Error;

use crate::codegen::{OpenApiSchema, SCHEMA_REF_PREFIX, strip_schema_ref_prefix};
use crate::util::codegen_buf::CodegenBuf;

pub fn render(schemas: BTreeMap<String, OpenApiSchema>) -> Result<CodegenBuf, Box<dyn Error>> {
    let schemas = topological_sort(&schemas)?;

    let mut buf = CodegenBuf::default();
    buf.writeln("# Code generated by turbopuffer-apigen. DO NOT EDIT.");
    buf.writeln("");
    buf.writeln("from typing import Any, Tuple, Union, Literal, Sequence, TypedDict");
    buf.writeln("");
    for (name, schema) in schemas {
        buf.start_line();
        buf.write(format!("{name} = "));
        render_schema(&mut buf, &name, schema)?;
        buf.end_line();
    }
    Ok(buf)
}

fn topological_sort(
    schemas: &BTreeMap<String, OpenApiSchema>,
) -> Result<Vec<(String, OpenApiSchema)>, Box<dyn Error>> {
    fn visit<'a>(
        schemas: &'a BTreeMap<String, OpenApiSchema>,
        visited: &mut HashSet<&'a str>,
        result: &mut Vec<(String, OpenApiSchema)>,
        schema: &OpenApiSchema,
    ) -> Result<(), Box<dyn Error>> {
        match schema {
            OpenApiSchema::Ref { sref, .. } => {
                let name = strip_schema_ref_prefix(sref)?;
                let Some((name, schema)) = schemas.get_key_value(name) else {
                    return Err(format!("schema not found: {name}").into());
                };
                if visited.contains(name.as_str()) {
                    return Ok(());
                }
                visited.insert(name);
                visit(schemas, visited, result, schema)?;
                result.push((name.clone(), schema.clone()))
            }
            OpenApiSchema::AnyOf {
                _description: _,
                any_of,
            } => {
                for schema in any_of {
                    visit(schemas, visited, result, schema)?;
                }
            }
            OpenApiSchema::ArrayList { items, .. } => {
                visit(schemas, visited, result, items)?;
            }
            OpenApiSchema::ArrayTuple { prefix_items, .. } => {
                for schema in prefix_items {
                    visit(schemas, visited, result, schema)?;
                }
            }
            OpenApiSchema::Object { properties, .. } => {
                for (_, schema) in properties {
                    visit(schemas, visited, result, schema)?;
                }
            }
            _ => {}
        };

        Ok(())
    }

    let mut result = Vec::new();
    let mut visited = HashSet::new();
    for name in schemas.keys() {
        let schema = OpenApiSchema::Ref {
            sref: format!("{SCHEMA_REF_PREFIX}{name}"),
            title: None,
        };
        visit(&schemas, &mut visited, &mut result, &schema)?;
    }

    Ok(result)
}

fn render_schema(
    buf: &mut CodegenBuf,
    name: &str,
    schema: OpenApiSchema,
) -> Result<(), Box<dyn Error>> {
    match schema {
        OpenApiSchema::AnyOf {
            _description: _,
            any_of,
        } => {
            let multiple = any_of.len() > 1;
            let expanded = any_of.len() > 3;
            if multiple {
                buf.write("Union[");
            }
            if expanded {
                buf.indent();
                buf.end_line();
                buf.start_line();
            }
            for (i, schema) in any_of.into_iter().enumerate() {
                if i > 0 {
                    if expanded {
                        buf.start_line();
                    } else {
                        buf.write(", ");
                    }
                }
                render_schema(buf, name, schema)?;
                if expanded {
                    buf.write(",");
                    buf.end_line();
                }
            }
            if expanded {
                buf.unindent();
            }
            if multiple {
                buf.write("]");
            }
        }
        OpenApiSchema::Object {
            _description: _,
            _type: _,
            properties,
            required,
            title: _,
        } => {
            if !properties.keys().all(|name| required.contains(name)) {
                Err("object schemas with non-required properties not supported")?
            };
            buf.write(format!("TypedDict(\"{name}\", {{"));
            for (i, (name, schema)) in properties.into_iter().enumerate() {
                if i > 0 {
                    buf.write(", ");
                }
                buf.write(format!("\"{name}\": "));
                render_schema(buf, &name, schema)?;
            }
            buf.write("})")
        }
        OpenApiSchema::ArrayList {
            _description: _,
            _type: _,
            items,
            title: _,
        } => {
            buf.write("Sequence[");
            render_schema(buf, name, *items)?;
            buf.write("]")
        }
        OpenApiSchema::ArrayTuple {
            additional_items: true,
            ..
        } => Err("tuple-type arrays with `items: true` unsupported")?,
        OpenApiSchema::ArrayTuple {
            _description: _,
            _type: _,
            additional_items: false,
            prefix_items,
            x_turbopuffer_variant_name: _,
            x_turbopuffer_variant_drop_on_conflict: _,
            x_turbopuffer_flatten: _,
            title: _,
        } => {
            buf.write("Tuple[");
            for (i, schema) in prefix_items.into_iter().enumerate() {
                if i > 0 {
                    buf.write(", ");
                }
                render_schema(buf, name, schema)?;
            }
            buf.write("]")
        }
        OpenApiSchema::String {
            _description: _,
            _type: _,
            title: _,
        } => buf.write("str"),
        OpenApiSchema::Number {
            _description: _,
            _type: _,
            title: _,
            x_turbopuffer_width: _,
        } => buf.write("float"),
        OpenApiSchema::Const {
            _description: _,
            sconst,
            title: _,
        } => buf.write(format!("Literal[\"{sconst}\"]")),
        OpenApiSchema::Ref { sref, title: _ } => {
            let ref_name = strip_schema_ref_prefix(&sref)?;
            if ref_name == name {
                // Recursive references (i.e., references to the name we're
                // currently defining) need to be quoted.
                buf.write(format!("\"{ref_name}\""))
            } else {
                buf.write(ref_name)
            }
        }
        OpenApiSchema::Any { .. } => buf.write("Any"),
    }
    Ok(())
}
