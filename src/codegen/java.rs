use std::{collections::BTreeMap, error::Error};

use crate::{
    codegen::{
        OpenApiSchema,
        shared::{self, ConflictBehavior, TupleField},
        strip_schema_ref_prefix,
    },
    util::codegen_buf::CodegenBuf,
};

pub fn render(mut schemas: BTreeMap<String, OpenApiSchema>) -> Result<CodegenBuf, Box<dyn Error>> {
    shared::extract_any_of_tuples(&mut schemas, ConflictBehavior::AppendSuffix)?;
    let ctx = RenderCtx {
        inherits: compute_inherits(&schemas)?,
        objects_as_tuples: rewrite_single_field_objects_to_tuples(&mut schemas)?,
        schemas,
    };

    let mut buf = CodegenBuf::default();

    buf.writeln("// Code generated by turbopuffer-apigen. DO NOT EDIT.");
    buf.writeln("");
    buf.writeln("package com.turbopuffer.models.namespaces");
    buf.writeln("");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonFormat");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonAutoDetect");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonIgnore");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonProperty");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonPropertyOrder");
    buf.writeln("import com.turbopuffer.core.JsonValue");
    buf.writeln("");

    for (i, (name, schema)) in ctx.schemas.iter().enumerate() {
        if i > 0 {
            buf.writeln("");
        }
        render_schema(&ctx, &mut buf, &name, &schema)?;
    }

    Ok(buf)
}

struct RenderCtx {
    inherits: BTreeMap<String, String>,
    /// Names of objects that have been munged into tuples, and any JSON name
    /// overrides for the fields.
    objects_as_tuples: BTreeMap<String, BTreeMap<String, String>>,
    schemas: BTreeMap<String, OpenApiSchema>,
}

fn compute_inherits(
    schemas: &BTreeMap<String, OpenApiSchema>,
) -> Result<BTreeMap<String, String>, Box<dyn Error>> {
    let mut result = BTreeMap::new();
    for (name, schema) in schemas {
        match schema {
            OpenApiSchema::AnyOf {
                _description: _,
                any_of,
            } => {
                for schema in any_of {
                    if let OpenApiSchema::Ref { sref, .. } = schema {
                        let sref = strip_schema_ref_prefix(sref)?;
                        let existing = result.insert(sref.into(), name.into());
                        if let Some(existing) = existing {
                            Err(format!(
                                "duplicate inheritance for {sref}: {existing} and {name}"
                            ))?
                        }
                    }
                }
            }
            _ => (),
        }
    }
    Ok(result)
}

fn rewrite_single_field_objects_to_tuples(
    schemas: &mut BTreeMap<String, OpenApiSchema>,
) -> Result<BTreeMap<String, BTreeMap<String, String>>, Box<dyn Error>> {
    let mut names = BTreeMap::new();
    for (name, schema) in schemas {
        match schema {
            OpenApiSchema::Object {
                _description: _,
                _type: _,
                properties,
                required,
                title: _,
            } if properties.len() == 1 && required.len() == 1 => {
                let (prop_name, prop_schema) = properties.into_iter().next().unwrap();
                if !required.contains(prop_name) {
                    continue;
                }
                let prop_name = prop_name.clone();
                let prop_name_munged = shared::snake_to_camel_case(&prop_name);
                if let Some(title) = prop_schema.title_mut() {
                    *title = Some(prop_name_munged.clone());
                }
                *schema = OpenApiSchema::ArrayTuple {
                    prefix_items: vec![prop_schema.clone()],
                    _description: None,
                    _type: Default::default(),
                    additional_items: false,
                    x_turbopuffer_variant_name: None,
                    x_turbopuffer_variant_drop_on_conflict: false,
                    x_turbopuffer_flatten: false,
                    title: None,
                };
                let overrides = BTreeMap::from([(prop_name_munged, prop_name)]);
                names.insert(name.clone(), overrides);
            }
            _ => (),
        }
    }
    Ok(names)
}

fn render_schema(
    ctx: &RenderCtx,
    buf: &mut CodegenBuf,
    name: &str,
    schema: &OpenApiSchema,
) -> Result<(), Box<dyn Error>> {
    match schema {
        OpenApiSchema::AnyOf {
            _description: _,
            any_of,
        } => {
            if any_of
                .iter()
                .all(|s| matches!(s, OpenApiSchema::Const { .. }))
            {
                render_any_of_const_enum(buf, name, any_of)?;
            } else if any_of
                .iter()
                .all(|s| matches!(s, OpenApiSchema::Ref { .. }))
            {
                render_any_of_refs(ctx, buf, name, any_of)?;
            } else {
                Err("unsupported anyOf")?
            }
        }
        OpenApiSchema::Object { .. } => Err("object schemas unsupported")?,
        OpenApiSchema::ArrayList {
            _description: _,
            _type: _,
            items,
            title: _,
        } => {
            buf.write("List<");
            render_schema(ctx, buf, name, &*items)?;
            buf.write(">");
        }
        OpenApiSchema::ArrayTuple {
            additional_items: true,
            ..
        } => Err("tuple-type arrays with `items: true` unsupported")?,
        OpenApiSchema::ArrayTuple {
            _description: _,
            _type: _,
            additional_items: false,
            prefix_items,
            x_turbopuffer_variant_name: _,
            x_turbopuffer_variant_drop_on_conflict: _,
            x_turbopuffer_flatten: _,
            title: _,
        } => {
            // Since Java doesn't natively support tuples, we convert each tuple
            // to a class with private fields and a constructor function that
            // takes the fields as arguments, in the order the tuple defines
            // them.

            let fields = shared::build_tuple_fields(prefix_items);

            // Instruct Jackson to emit private fields too.
            buf.writeln("@JsonAutoDetect(fieldVisibility = Visibility.ANY)");

            // Emit JSON property order.
            if !ctx.objects_as_tuples.contains_key(name) {
                buf.writeln("@JsonFormat(shape = JsonFormat.Shape.ARRAY)");
            }
            buf.write("@JsonPropertyOrder(");
            let mut f_idx = 0;
            let mut level = 0;
            for field in &fields {
                match field {
                    TupleField::StartIndent => {
                        level += 1;
                        if level > 1 {
                            continue;
                        }
                    }
                    TupleField::EndIndent => {
                        level -= 1;
                        continue;
                    }
                    TupleField::Normal { .. } | TupleField::Const(_) => {
                        if level > 0 {
                            continue;
                        }
                    }
                }
                match field {
                    TupleField::Normal { name, .. } => {
                        buf.write(format!("\"{name}\","));
                    }
                    _ => {
                        buf.write(format!("\"f{f_idx}\","));
                        f_idx += 1;
                    }
                }
            }
            buf.write(")");
            buf.end_line();

            // Start class declaration.
            buf.start_line();
            buf.write(format!("class {name} private constructor("));

            // Constructor declaration.
            for field in &fields {
                if let TupleField::Normal { name, schema } = field {
                    buf.write(format!("{name}: "));
                    render_schema(ctx, buf, name, schema)?;
                    buf.write(", ");
                }
            }

            // Inherits declaration.
            buf.write(")");
            if let Some(inherits) = ctx.inherits.get(name) {
                buf.write(format!(" : {inherits}()"));
            }
            buf.write(" {");
            buf.end_line();

            // Class body.
            buf.indent();
            let mut f_idx = 0;
            let mut level = 0;
            for field in &fields {
                match field {
                    TupleField::StartIndent => {
                        level += 1;
                        if level == 1 {
                            buf.start_line();
                            buf.write(format!("private val f{f_idx}: List<JsonValue> = listOf("));
                            f_idx += 1;
                        }
                    }
                    TupleField::EndIndent => {
                        level -= 1;
                        buf.write(")");
                        if level == 0 {
                            buf.end_line();
                        }
                    }
                    TupleField::Normal {
                        name: prop_name,
                        schema,
                    } => {
                        if level == 0 {
                            buf.start_line();
                            let json_name = ctx
                                .objects_as_tuples
                                .get(name)
                                .and_then(|overrides| overrides.get(prop_name))
                                .map(|json_name| json_name.replace("$", "\\$"));
                            if let Some(json_name) = json_name {
                                buf.write(format!("@JsonProperty(\"{json_name}\") "));
                            }
                            match schema {
                                // Special case to transparently transform `any`
                                // fields into `JsonValue`s. This only works for
                                // top-level fields; would need to be extended
                                // in the future to work for e.g. `List<Any>`.
                                OpenApiSchema::Any { .. } => {
                                    buf.write(format!(
                                        "private val {prop_name}: JsonValue = JsonValue.from({prop_name})"
                                    ));
                                }
                                _ => {
                                    buf.write(format!("private val {prop_name}: "));
                                    render_schema(ctx, buf, prop_name, schema)?;
                                    buf.write(format!(" = {prop_name}"));
                                }
                            }
                            buf.end_line();
                        } else {
                            buf.write(format!("JsonValue.from({prop_name}),"));
                        }
                    }
                    TupleField::Const(sconst) => {
                        if level == 0 {
                            buf.writeln(format!("private val f{f_idx}: String = \"{sconst}\""));
                            f_idx += 1;
                        } else {
                            buf.write(format!("JsonValue.from(\"{sconst}\"),"));
                        }
                    }
                }
            }
            buf.unindent();

            buf.write_block("companion object", |buf| {
                buf.writeln("@JvmSynthetic");
                render_array_tuple_constructor(RenderArrayTupleConstructorParams {
                    ctx,
                    buf,
                    new_func_vis: "internal",
                    new_func_name: "create",
                    new_func_can_use_vararg: false,
                    class_name: &name,
                    old_func_name: &name,
                    prefix_items,
                })
            })?;

            // End class declaration.
            buf.writeln("}");
        }
        OpenApiSchema::String {
            _description: _,
            _type: _,
            title: _,
        } => buf.write("String"),
        OpenApiSchema::Number {
            _description: _,
            _type: _,
            title: _,
            x_turbopuffer_width,
        } => match x_turbopuffer_width {
            Some(32) => buf.write("Float"),
            None | Some(64) => buf.write("Double"),
            Some(w) => Err(format!("unsupported number width: {w}"))?,
        },
        OpenApiSchema::Const {
            _description: _,
            sconst: _,
            title: _,
        } => Err("const in unsupported position")?,
        OpenApiSchema::Ref { sref, title: _ } => {
            let name = strip_schema_ref_prefix(sref)?;
            buf.write(name)
        }
        OpenApiSchema::Any { .. } => buf.write("Any"),
    }
    Ok(())
}

fn render_any_of_const_enum(
    buf: &mut CodegenBuf,
    name: &str,
    schema: &[OpenApiSchema],
) -> Result<(), Box<dyn Error>> {
    // When all the items in an `anyOf` are consts, we can generate a string
    // enum for the `anyOf`.
    // This is a workaround for Java's lack of sum types.

    buf.write_block(format!("enum class {name}"), |buf| {
        for item in schema {
            let OpenApiSchema::Const {
                _description: _,
                title: x_turbopuffer_name,
                sconst,
            } = item
            else {
                unreachable!("validated by render_schema");
            };
            let sconst_name = x_turbopuffer_name.clone().unwrap_or_else(|| {
                let mut sconst_name = String::new();
                let mut chars = sconst.chars();
                if let Some(first_char) = chars.next() {
                    sconst_name.extend(first_char.to_uppercase());
                }
                while let Some(c) = chars.next() {
                    if c.is_uppercase() {
                        sconst_name.push('_');
                    }
                    sconst_name.extend(c.to_uppercase());
                }
                sconst_name
            });
            buf.writeln(format!("@JsonProperty(\"{sconst}\") {sconst_name}, "));
        }
    });

    Ok(())
}

fn render_any_of_refs(
    ctx: &RenderCtx,
    buf: &mut CodegenBuf,
    name: &str,
    schema: &[OpenApiSchema],
) -> Result<(), Box<dyn Error>> {
    // When all the items in an `anyOf` are refs, we can generate a sealed
    // interface for the `anyOf` and implement it for all the referenced types.
    // This is a workaround for Java's lack of sum types.

    // Class declaration.
    let mut class_decl = format!("sealed class {name}()");
    if let Some(inherits) = ctx.inherits.get(name) {
        class_decl.push_str(&format!(" : {inherits}()"));
    }

    // Methods to construct child classes.
    buf.write_block(&class_decl, |buf| {
        buf.write_block("companion object", |buf| {
            for item in schema {
                let OpenApiSchema::Ref { sref, title } = item else {
                    unreachable!("validated by render_schema");
                };
                let sref = strip_schema_ref_prefix(sref)?;
                let subname = title.as_deref().unwrap_or(sref);
                if let OpenApiSchema::ArrayTuple { prefix_items, .. } = &ctx.schemas[sref] {
                    let new_func_name = {
                        let s = subname.strip_prefix(name).unwrap_or(subname);
                        let s = shared::lower_camel_case(&s);
                        munge_func_name(&s)
                    };

                    buf.writeln("@JvmStatic");
                    render_array_tuple_constructor(RenderArrayTupleConstructorParams {
                        ctx,
                        buf,
                        new_func_vis: "public",
                        new_func_name: &new_func_name,
                        new_func_can_use_vararg: true,
                        class_name: &sref,
                        old_func_name: &format!("{sref}.create"),
                        prefix_items,
                    })?;
                }
            }
            Ok::<_, Box<dyn Error>>(())
        })
    })
}

struct RenderArrayTupleConstructorParams<'a> {
    ctx: &'a RenderCtx,
    buf: &'a mut CodegenBuf,
    new_func_vis: &'a str,
    new_func_name: &'a str,
    new_func_can_use_vararg: bool,
    class_name: &'a str,
    old_func_name: &'a str,
    prefix_items: &'a [OpenApiSchema],
}

fn render_array_tuple_constructor(
    RenderArrayTupleConstructorParams {
        ctx,
        buf,
        new_func_vis,
        new_func_name,
        new_func_can_use_vararg,
        class_name,
        old_func_name,
        prefix_items,
    }: RenderArrayTupleConstructorParams,
) -> Result<(), Box<dyn Error>> {
    let fields = shared::build_tuple_fields(prefix_items);

    let normal_field_count = fields
        .iter()
        .filter(|f| matches!(f, TupleField::Normal { .. }))
        .count();
    let use_vararg = normal_field_count == 1 && new_func_can_use_vararg;

    buf.start_line();
    buf.write(format!("{new_func_vis} fun {new_func_name}("));
    for field in fields.iter() {
        if let TupleField::Normal { name, schema } = field {
            match schema {
                OpenApiSchema::ArrayList { items, .. } if use_vararg => {
                    buf.write(format!("vararg {name}: "));
                    render_schema(ctx, buf, name, items)?;
                }
                _ => {
                    buf.write(format!("{name}: "));
                    render_schema(ctx, buf, name, schema)?;
                    buf.write(", ");
                }
            }
        }
    }
    buf.write(format!("): {class_name} = {old_func_name}("));
    for field in fields.iter() {
        if let TupleField::Normal { name, schema } = field {
            match schema {
                OpenApiSchema::ArrayList { .. } if use_vararg => {
                    buf.write(format!("{name}.asList(),"));
                }
                _ => buf.write(format!("{name},")),
            }
        }
    }
    buf.write(")");
    buf.end_line();

    Ok(())
}

fn munge_func_name(s: &str) -> String {
    match s {
        "in" => "`in`".to_string(),     // Kotlin reserved word
        "iglob" => "iGlob".to_string(), // tricky to camelCase correctly automatically
        _ => s.to_string(),
    }
}
