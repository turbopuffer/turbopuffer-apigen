use std::{collections::BTreeMap, error::Error};

use crate::{
    codegen::{
        OpenApiSchema,
        shared::{self, TupleField},
        strip_schema_ref_prefix,
    },
    util::codegen_buf::CodegenBuf,
};

pub fn render(mut schemas: BTreeMap<String, OpenApiSchema>) -> Result<CodegenBuf, Box<dyn Error>> {
    shared::extract_any_of_tuples(&mut schemas)?;
    let inherits = compute_inherits(&schemas)?;

    let mut buf = CodegenBuf::default();

    buf.writeln("// Code generated by turbopuffer-apigen. DO NOT EDIT.");
    buf.writeln("");
    buf.writeln("package com.turbopuffer.models.namespaces");
    buf.writeln("");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonFormat");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonAutoDetect");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonIgnore");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonProperty");
    buf.writeln("import com.fasterxml.jackson.annotation.JsonPropertyOrder");
    buf.writeln("import com.turbopuffer.core.JsonValue");
    buf.writeln("");

    for (i, (name, schema)) in schemas.iter().enumerate() {
        if i > 0 {
            buf.writeln("");
        }
        render_schema(&inherits, &schemas, &mut buf, &name, &schema)?;
    }

    Ok(buf)
}

fn compute_inherits(
    schemas: &BTreeMap<String, OpenApiSchema>,
) -> Result<BTreeMap<String, String>, Box<dyn Error>> {
    let mut result = BTreeMap::new();
    for (name, schema) in schemas {
        match schema {
            OpenApiSchema::AnyOf {
                _description: _,
                any_of,
            } => {
                for schema in any_of {
                    if let OpenApiSchema::Ref { sref, .. } = schema {
                        let sref = strip_schema_ref_prefix(sref)?;
                        let existing = result.insert(sref.into(), name.into());
                        if let Some(existing) = existing {
                            Err(format!(
                                "duplicate inheritance for {sref}: {existing} and {name}"
                            ))?
                        }
                    }
                }
            }
            _ => (),
        }
    }
    Ok(result)
}

fn render_schema(
    inherits: &BTreeMap<String, String>,
    schemas: &BTreeMap<String, OpenApiSchema>,
    buf: &mut CodegenBuf,
    name: &str,
    schema: &OpenApiSchema,
) -> Result<(), Box<dyn Error>> {
    match schema {
        OpenApiSchema::AnyOf {
            _description: _,
            any_of,
        } => {
            if any_of
                .iter()
                .all(|s| matches!(s, OpenApiSchema::Const { .. }))
            {
                render_any_of_const_enum(buf, name, any_of)?;
            } else if any_of
                .iter()
                .all(|s| matches!(s, OpenApiSchema::Ref { .. }))
            {
                render_any_of_refs(inherits, schemas, buf, name, any_of)?;
            } else {
                Err("unsupported anyOf")?
            }
        }
        OpenApiSchema::Object { .. } => Err("object schemas unsupported")?,
        OpenApiSchema::ArrayList {
            _description: _,
            _type: _,
            items,
            title: _,
        } => {
            buf.write("List<");
            render_schema(inherits, schemas, buf, name, &*items)?;
            buf.write(">");
        }
        OpenApiSchema::ArrayTuple {
            additional_items: true,
            ..
        } => Err("tuple-type arrays with `items: true` unsupported")?,
        OpenApiSchema::ArrayTuple {
            _description: _,
            _type: _,
            additional_items: false,
            prefix_items,
            x_turbopuffer_variant_name: _,
            x_turbopuffer_variant_drop_on_conflict: _,
            x_turbopuffer_flatten: _,
            title: _,
        } => {
            // Since Java doesn't natively support tuples, we convert each tuple
            // to a class with private fields and a constructor function that
            // takes the fields as arguments, in the order the tuple defines
            // them.

            let fields = shared::build_tuple_fields(prefix_items);

            // Instruct Jackson to emit private fields too.
            buf.writeln("@JsonAutoDetect(fieldVisibility = Visibility.ANY)");

            // Emit JSON property order.
            buf.writeln("@JsonFormat(shape = JsonFormat.Shape.ARRAY)");
            buf.write("@JsonPropertyOrder(");
            let mut f_idx = 0;
            let mut level = 0;
            for field in &fields {
                match field {
                    TupleField::StartIndent => {
                        level += 1;
                        if level > 1 {
                            continue;
                        }
                    }
                    TupleField::EndIndent => {
                        level -= 1;
                        continue;
                    }
                    TupleField::Normal { .. } | TupleField::Const(_) => {
                        if level > 0 {
                            continue;
                        }
                    }
                }
                match field {
                    TupleField::Normal { name, .. } => {
                        buf.write(format!("\"{name}\","));
                    }
                    _ => {
                        buf.write(format!("\"f{f_idx}\","));
                        f_idx += 1;
                    }
                }
            }
            buf.write(")");
            buf.end_line();

            // Start class declaration.
            buf.start_line();
            buf.write(format!("class {name} private constructor("));

            // Constructor declaration.
            let mut level = 0;
            for field in &fields {
                match field {
                    TupleField::StartIndent => level += 1,
                    TupleField::EndIndent => level -= 1,
                    TupleField::Normal { name, schema } => {
                        if level > 0 {
                            buf.write("@JsonIgnore ");
                        }
                        buf.write(format!("private val {name}: "));
                        render_schema(inherits, schemas, buf, name, schema)?;
                        buf.write(", ");
                    }
                    TupleField::Const(_) => (),
                }
            }

            // Inherits declaration.
            buf.write(")");
            if let Some(inherits) = inherits.get(name) {
                buf.write(format!(" : {inherits}()"));
            }
            buf.write(" {");
            buf.end_line();

            // Class body.
            buf.indent();
            let mut f_idx = 0;
            let mut level = 0;
            for field in &fields {
                match field {
                    TupleField::StartIndent => {
                        level += 1;
                        if level == 1 {
                            buf.start_line();
                            buf.write(format!("private val f{f_idx}: List<JsonValue> = listOf("));
                            f_idx += 1;
                        }
                    }
                    TupleField::EndIndent => {
                        level -= 1;
                        buf.write(")");
                        if level == 0 {
                            buf.end_line();
                        }
                    }
                    TupleField::Normal { name, .. } => {
                        if level > 0 {
                            buf.write(format!("JsonValue.from({name}),"));
                        }
                    }
                    TupleField::Const(sconst) => {
                        if level == 0 {
                            buf.writeln(format!("private val f{f_idx}: String = \"{sconst}\""));
                            f_idx += 1;
                        } else {
                            buf.write(format!("JsonValue.from(\"{sconst}\"),"));
                        }
                    }
                }
            }
            buf.unindent();

            buf.write_block("companion object", |buf| {
                buf.writeln("@JvmSynthetic");
                render_array_tuple_constructor(
                    inherits,
                    schemas,
                    buf,
                    "internal",
                    &format!("create"),
                    &name,
                    &name,
                    prefix_items,
                )
            })?;

            // End class declaration.
            buf.writeln("}");
        }
        OpenApiSchema::String {
            _description: _,
            _type: _,
            title: _,
        } => buf.write("String"),
        OpenApiSchema::Number {
            _description: _,
            _type: _,
            title: _,
            x_turbopuffer_width,
        } => match x_turbopuffer_width {
            Some(32) => buf.write("Float"),
            None | Some(64) => buf.write("Double"),
            Some(w) => Err(format!("unsupported number width: {w}"))?,
        },
        OpenApiSchema::Const {
            _description: _,
            sconst: _,
            title: _,
        } => Err("const in unsupported position")?,
        OpenApiSchema::Ref { sref, title: _ } => {
            let name = strip_schema_ref_prefix(sref)?;
            buf.write(name)
        }
        OpenApiSchema::Any { .. } => buf.write("JsonValue"),
    }
    Ok(())
}

fn render_any_of_const_enum(
    buf: &mut CodegenBuf,
    name: &str,
    schema: &[OpenApiSchema],
) -> Result<(), Box<dyn Error>> {
    // When all the items in an `anyOf` are consts, we can generate a string
    // enum for the `anyOf`.
    // This is a workaround for Java's lack of sum types.

    buf.write_block(format!("enum class {name}"), |buf| {
        for item in schema {
            let OpenApiSchema::Const {
                _description: _,
                title: x_turbopuffer_name,
                sconst,
            } = item
            else {
                unreachable!("validated by render_schema");
            };
            let sconst_name = x_turbopuffer_name.clone().unwrap_or_else(|| {
                let mut sconst_name = String::new();
                let mut chars = sconst.chars();
                if let Some(first_char) = chars.next() {
                    sconst_name.extend(first_char.to_uppercase());
                }
                while let Some(c) = chars.next() {
                    if c.is_uppercase() {
                        sconst_name.push('_');
                    }
                    sconst_name.extend(c.to_uppercase());
                }
                sconst_name
            });
            buf.writeln(format!("@JsonProperty(\"{sconst}\") {sconst_name}, "));
        }
    });

    Ok(())
}

fn render_any_of_refs(
    inherits: &BTreeMap<String, String>,
    schemas: &BTreeMap<String, OpenApiSchema>,
    buf: &mut CodegenBuf,
    name: &str,
    schema: &[OpenApiSchema],
) -> Result<(), Box<dyn Error>> {
    // When all the items in an `anyOf` are refs, we can generate a sealed
    // interface for the `anyOf` and implement it for all the referenced types.
    // This is a workaround for Java's lack of sum types.

    // Class declaration.
    let mut class_decl = format!("sealed class {name}()");
    if let Some(inherits) = inherits.get(name) {
        class_decl.push_str(&format!(" : {inherits}()"));
    }

    // Methods to construct child classes.
    buf.write_block(&class_decl, |buf| {
        buf.write_block("companion object", |buf| {
            for item in schema {
                let OpenApiSchema::Ref { sref, .. } = item else {
                    unreachable!("validated by render_schema");
                };
                let sref = strip_schema_ref_prefix(sref)?;
                if let OpenApiSchema::ArrayTuple { prefix_items, .. } = &schemas[sref] {
                    let new_func_name = {
                        let mut s = String::new();
                        let mut chars = sref.strip_prefix(name).unwrap_or(sref).chars();
                        while let Some(c) = chars.next() {
                            s.extend(c.to_lowercase());
                            if !c.is_uppercase() {
                                break;
                            }
                        }
                        s.extend(chars);
                        munge_func_name(&s)
                    };

                    buf.writeln("@JvmStatic");
                    render_array_tuple_constructor(
                        inherits,
                        schemas,
                        buf,
                        "public",
                        &new_func_name,
                        &sref,
                        &format!("{sref}.create"),
                        prefix_items,
                    )?;
                }
            }
            Ok::<_, Box<dyn Error>>(())
        })
    })
}

fn render_array_tuple_constructor(
    inherits: &BTreeMap<String, String>,
    schemas: &BTreeMap<String, OpenApiSchema>,
    buf: &mut CodegenBuf,
    new_func_vis: &str,
    new_func_name: &str,
    class_name: &str,
    old_func_name: &str,
    prefix_items: &[OpenApiSchema],
) -> Result<(), Box<dyn Error>> {
    let fields = shared::build_tuple_fields(prefix_items);

    buf.start_line();
    buf.write(format!("{new_func_vis} fun {new_func_name}("));
    for field in &fields {
        if let TupleField::Normal { name, schema } = field {
            buf.write(format!("{name}: "));
            render_schema(inherits, schemas, buf, name, schema)?;
            buf.write(", ");
        }
    }
    buf.write(format!("): {class_name} = {old_func_name}("));
    for field in &fields {
        if let TupleField::Normal { name, .. } = field {
            buf.write(format!("{name},"));
        }
    }
    buf.write(")");
    buf.end_line();

    Ok(())
}

fn munge_func_name(s: &str) -> String {
    match s {
        "in" => "`in`".to_string(),     // Kotlin reserved word
        "iglob" => "iGlob".to_string(), // tricky to camelCase correctly automatically
        _ => s.to_string(),
    }
}
